(References: [Full Codebase](https://github.com/travisBumgarner/photo20), [Live Website](http://travisbumgarner.photography/))

## Intro

A solid website experience is the result of a joint effort between a designer and a frontend engineer. Each individual brings their own expertise to the table. Through collaboration, they build something better than either could have built in isolation. As frontend engineers, we are accustomed to taking designs, implementing them, and then moving on. However, there are skills that engineers possess, that designers don't, that can bring user experiences to the next level.

## Different Vantage Points

Designers operate in an artificial environment. There are no network requests. Screen sizes tend to be fixed. Performance is not a concern. This is not the fault of the designer. Figma is not Google Chrome. Figma is far removed from the real world of slow internet connections and devices with limited processing power.

Frontend engineers live the opposite experience. They are concerned with interactions within the browser. They contemplate network requests, latency, caching, memoizing, rendering, bundling, lazy loading, browser behavior, and so much more. All of these terms are very technical. However, the end result of their implementation is to improve the user experience.

Engineers are tackling the exact same problem as design but from a different perspective. Engineers have the power to implement these techniques to improve the user experience.

## What to Focus On

The first step to improving the user experience is to decide what to work on.

Schooling teaches us to think of performance in abstract terms. Big O. Big Omega. Big Theta. Little o. All of these are very abstract methods of defining performance. They're far removed from the real world. They have their place, but it's not in this article.

Imagine you're looking for some improvements to make. You find some code in the frontend that theoretically has poor performance. It can be refactored to have better performance. In reality, its average run time is 50ms. Blinking takes roughly 100ms. <sub>[1]</sub> This is not the best use of your time.

To figure out what to work on, look at real situations. Real devices. Real internet connections. Real complaints. Focus there.

## An Example

(For technical details, check out the next section)

When a user visits <a>https://travisbumgarner.photography/</a>, their entire journey consists of browsing galleries and viewing full resolution photos. How can we anticipate their actions?

**Users want to see the content as quickly as possible.**

As the page is loading, prioritize what the user can see within their viewport. Use placeholder images, such as blurhashes, to let the user know that things are loading. Put priority on the visible thumbnails and defer everything else for later. As the user scrolls the page, prioritize loading the thumbnails the user will see next.

**Users will want to browse a gallery.**

Apply the techniques from the previous section. 

In addition, now that the user is browsing a gallery, their next action will be to select a thumbnail and view it in full resolution. Once all thumbnails are loaded, begin loading full resolution photos of the thumbnails they can see. 

**Users want to browse full resolution photos.**

Due to the previous step, the photo the user has selected was already loaded. Their next moves are to either look at the previous or next full resolution images. We can again use the technique in the previous section and prioritize loading those images. 

## Learn More

I originally had this and the previous section together. However, I realized that a deep technical dive is not the point of this article. Each situation requires vastly different technical solutions. I will leave this section should you wish to learn about specific technologies and techniques I used.

TODO - cleanup links. Maybe include more.

- [Preload resources](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/preload) - HTML `<link>` tags in the `<head>` of the document have a `rel` attribute which can be set to `preload`. The first few photos on the page can be inserted into the `<head>`. This will cause these resources to take priority on loading.
- [Lazy Loading](https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/Lazy_loading) - The `<img>` tag has property `loading` which can be set to `lazy`. This tells the browser to defer loading of an image.
- [React Motion useInView] - Helper util to determine if an element is within the user's viewport or about to be.
- [Blurhash]() - TODO
- [Code Example of Previous Points](https://github.com/TravisBumgarner/Photography-Portfolio/blob/2aa42cca8953b7e5ce6573607a6866f84bdaddcd/ui/src/sharedComponents/BlurImage.tsx#L2)
- [Code Example of Loading images programmatically](https://github.com/TravisBumgarner/Photography-Portfolio/blob/2aa42cca8953b7e5ce6573607a6866f84bdaddcd/ui/src/components/Gallery.tsx)
- [First Contentful Paint](https://web.dev/articles/fcp)
- [Largest Contentful Paint](https://web.dev/articles/lcp)

## Reflecting on the Experience

As engineers, we have more to contribute to great user experiences than we often realize. We understand the ins and outs of the applications we build - the user flows, the edge cases, and what happens after every click. By using that knowledge to complement and enhance what designers create, we can build experiences that go beyond what either could build alone.

## Footnotes

[1] https://en.wikipedia.org/wiki/Blinking
